<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labyrinthe ‚Äì Colorim√©trie (trace qui s'efface en arri√®re + liens)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --accent:#38bdf8; --accent2:#22c55e; --warn:#f43f5e; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial;
      display: grid; grid-template-rows: auto 1fr; gap: 10px; }
    header { display: grid; gap: 8px; padding: 10px; background: var(--panel);
      grid-template-columns: repeat(8, max-content) 1fr max-content; align-items: center; border-bottom: 1px solid #1f2937; }
    header h1 { font-size: 16px; margin: 0 8px 0 0; opacity:.9; font-weight:600; }
    label { font-size: 13px; opacity:.9; margin-right: 6px; }
    input, select, button { background: #0b1220; color: var(--ink); border: 1px solid #1f2937; padding: 6px 10px; border-radius: 10px; outline: none; }
    input[type="number"] { width: 84px; }
    input[type="checkbox"] { width:auto; accent-color:#38bdf8; }
    button { cursor: pointer; }
    button.primary { border-color: var(--accent); box-shadow: 0 0 0 2px #0b1220, 0 0 0 3px var(--accent); }
    .wrap { display:flex; align-items:center; gap:8px; }
    #container { display:grid; place-items:center; padding: 8px; }
    canvas { background:#fff; border-radius:14px; box-shadow: 0 8px 24px rgba(0,0,0,.35); touch-action: none; }
    .hud { position: fixed; left: 12px; bottom: 12px; background: rgba(2,6,23,.7);
      padding: 8px 12px; border: 1px solid #1f2937; border-radius: 12px; backdrop-filter: blur(4px);
      display:flex; gap:14px; align-items:center; font-size: 14px; }
    .tag { padding:2px 8px; border-radius:999px; background:#0b1220; border:1px solid #1f2937; }
    .legend { position: fixed; right: 12px; bottom: 12px; display:flex; gap:10px; align-items:center; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; }
    .dot.player { background: var(--accent); }
    .dot.goal { background: var(--accent2); }
    .dot.check { background: #f59e0b; }
    .modal { position: fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.5); z-index:10; }
    .card { width:min(560px, 92vw); background: #0b1220; border:1px solid #1f2937; border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.4); }
    .card h2 { margin:.2rem 0 1rem; font-size: 18px; }
    .choices { display:grid; gap:8px; margin: 10px 0 0; }
    .choices button { text-align: left; border-radius:12px; padding:10px 12px; }
    .choices button.correct { border-color: var(--accent2); }
    .choices button.wrong { border-color: var(--warn); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .muted { opacity:.7; font-size: 13px; }
  </style>
</head>
<body>
  <header>
    <h1>Labyrinthe ‚Äì Colorim√©trie</h1>
    <div class="wrap">
      <label for="size">Taille</label>
      <input id="rows" type="number" min="5" max="80" value="20" title="Lignes" />
      <span>√ó</span>
      <input id="cols" type="number" min="5" max="80" value="20" title="Colonnes" />
    </div>
    <div class="wrap">
      <label for="seed">Graine</label>
      <input id="seed" type="text" value="colorimetrie" placeholder="al√©atoire si vide" />
    </div>
    <div class="wrap">
      <label>Checkpoints</label>
      <input id="numChecks" type="number" min="0" max="12" value="7" />
    </div>
    <div class="wrap">
      <label>D√©part</label>
      <select id="startCorner">
        <option value="tl">Haut-Gauche</option>
        <option value="tr">Haut-Droite</option>
        <option value="bl">Bas-Gauche</option>
        <option value="br" selected>Bas-Droite</option>
      </select>
    </div>
    <div class="wrap">
      <label><input id="trail" type="checkbox" checked> Tracer le chemin (s'efface en arri√®re)</label>
    </div>
    <div class="wrap">
      <button id="regen" class="primary">G√©n√©rer</button>
      <button id="reset">Recommencer</button>
    </div>
    <div class="wrap" style="justify-self:end;">
      <span class="muted">Fl√®ches / ZQSD ‚Ä¢ Espace = pause</span>
    </div>
  </header>

  <div id="container">
    <canvas id="maze" width="720" height="720" aria-label="Labyrinthe"></canvas>
  </div>

  <div class="hud" id="hud">
    <span class="tag" id="steps">Pas: 0</span>
    <span class="tag" id="checks">Checkpoints: 0/0</span>
  </div>
  <div class="legend">
    <span class="tag"><span class="dot player"></span>Joueur</span>
    <span class="tag"><span class="dot check"></span>Checkpoint</span>
    <span class="tag"><span class="dot goal"></span>Sortie</span>
  </div>

  <div class="modal" id="modal">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <h2 id="qTitle">Question</h2>
        <button id="closeModal">‚úï</button>
      </div>
      <p id="qText" class="muted"></p>
      <div class="choices" id="qChoices"></div>
      <p class="muted" id="qHint" style="display:none;margin-top:10px;">Indice: essaye encore üòâ</p>
    </div>
  </div>

  <script>
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
  function hashString(str){let h=1779033703^str.length; for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353); h=h<<13|h>>>19;} return (h>>>0);}

  function generateMaze(R,C, rng){
    const OPP=[2,3,0,1];
    const walls = Array.from({length:R},()=>Array.from({length:C},()=>[true,true,true,true]));
    const vis = Array.from({length:R},()=>Array(C).fill(false));
    const dirs = [[-1,0],[0,1],[1,0],[0,-1]];
    const stack=[]; stack.push([0,0]); vis[0][0]=true;
    while(stack.length){
      const [r,c]=stack[stack.length-1];
      const neigh=[];
      for(let i=0;i<4;i++){
        const nr=r+dirs[i][0], nc=c+dirs[i][1];
        if(nr>=0 && nr<R && nc>=0 && nc<C && !vis[nr][nc]) neigh.push([i,nr,nc]);
      }
      if(neigh.length===0){ stack.pop(); continue; }
      const [i,nr,nc]=neigh[Math.floor(rng()*neigh.length)];
      walls[r][c][i]=false; walls[nr][nc][OPP[i]]=false; vis[nr][nc]=true; stack.push([nr,nc]);
    }
    return {walls};
  }

  function bfsPath(walls, start, goal){
    const R=walls.length, C=walls[0].length; const q=[start]; const prev=new Map();
    const key=([r,c])=>r+","+c; prev.set(key(start), null);
    const dirs=[[ -1,0],[0,1],[1,0],[0,-1]];
    while(q.length){
      const [r,c]=q.shift(); if(r===goal[0]&&c===goal[1]) break;
      for(let i=0;i<4;i++) if(!walls[r][c][i]){
        const nr=r+dirs[i][0], nc=c+dirs[i][1]; const k=nr+","+nc; if(!prev.has(k)){ prev.set(k,[r,c]); q.push([nr,nc]); }
      }
    }
    const out=[]; let cur=goal, k=key(cur); if(!prev.has(k)) return out;
    while(cur){ out.push(cur); cur=prev.get(key(cur)); }
    return out.reverse();
  }

  const canvas = document.getElementById('maze');
  const ctx = canvas.getContext('2d');
  const rowsInp = document.getElementById('rows');
  const colsInp = document.getElementById('cols');
  const seedInp = document.getElementById('seed');
  const numChecksInp = document.getElementById('numChecks');
  const startCornerSel = document.getElementById('startCorner');
  const stepsTag = document.getElementById('steps');
  const checksTag = document.getElementById('checks');
  const modal = document.getElementById('modal');
  const qTitle = document.getElementById('qTitle');
  const qText = document.getElementById('qText');
  const qChoices = document.getElementById('qChoices');
  const qHint = document.getElementById('qHint');
  const trailInp = document.getElementById('trail');

  let state={};

  // Colorim√©trie + liens
  const quizData = [
    { title: "M√©lange de couleurs",
      text: "Quelle couleur obtient-on en m√©langeant du bleu et du jaune ?",
      choices: [
        {label:"Orange", correct:false},
        {label:"Violet", correct:false},
        {label:"Vert", correct:true},
        {label:"Marron", correct:false}
      ]},
    { title: "Compl√©mentaires",
      text: "Quelle est la couleur compl√©mentaire du violet ?",
      choices: [
        {label:"Rouge", correct:false},
        {label:"Jaune", correct:true},
        {label:"Bleu", correct:false},
        {label:"Vert", correct:false}
      ]},
    { title: "Obtenir l‚Äôorange",
      text: "Quelles deux couleurs faut-il m√©langer pour obtenir de l‚Äôorange ?",
      choices: [
        {label:"Bleu + Jaune", correct:false},
        {label:"Rouge + Jaune", correct:true},
        {label:"Bleu + Rouge", correct:false},
        {label:"Vert + Rouge", correct:false}
      ]},
    { title: "Vrai ou Faux",
      text: "Le vert est une couleur secondaire obtenue en m√©langeant du bleu et du jaune.",
      choices: [
        {label:"Vrai", correct:true},
        {label:"Faux", correct:false}
      ]},
    { title: "Vrai ou Faux",
      text: "La couleur compl√©mentaire de l‚Äôorange est le rouge.",
      choices: [
        {label:"Vrai", correct:false},
        {label:"Faux", correct:true}
      ]}
  ];

  const linkData = [
    { url: "https://learningapps.org/watch?v=p9yu5unyc19", title:"Exercice LearningApps 1" },
    { url: "https://learningapps.org/watch?v=prvoiiyuc19", title:"Exercice LearningApps 2" }
  ];

  function newGame(){
    const R = Number(rowsInp.value)||20; const C = Number(colsInp.value)||20;
    const cell = Math.floor(Math.min(canvas.width/C, canvas.height/R));
    const padX = Math.floor((canvas.width - cell*C)/2);
    const padY = Math.floor((canvas.height - cell*R)/2);

    const seedText = seedInp.value.trim();
    const rng = seedText ? mulberry32(hashString(seedText)) : Math.random;

    const {walls} = generateMaze(R,C,rng);

    const corner = startCornerSel.value;
    let start=[0,0], goal=[R-1,C-1];
    if(corner==='tl'){ start=[0,0]; goal=[R-1,C-1]; }
    if(corner==='tr'){ start=[0,C-1]; goal=[R-1,0]; }
    if(corner==='bl'){ start=[R-1,0]; goal=[0,C-1]; }
    if(corner==='br'){ start=[R-1,C-1]; goal=[0,0]; }

    const path = bfsPath(walls, start, goal);

    const want = Number(numChecksInp.value)||7;

    // M√©lange quiz + liens (puis boucle si plus de checkpoints)
    const base = [...quizData, ...linkData.map(l=>({__link:true, ...l}))];
    const contents = [];
    for(let i=0;i<want;i++){ contents.push(base[i % base.length]); }

    const checkpoints=[];
    for(let i=1;i<=want;i++){
      const idx = Math.floor(i*(path.length-1)/(want+1));
      const [r,c] = path[idx];
      const ct = contents[i-1];
      if(ct.__link){
        checkpoints.push({r,c, cleared:false, url: ct.url, quiz: {title: ct.title, text: "Cette activit√© s'ouvre dans un nouvel onglet.", choices: []}});
      }else{
        checkpoints.push({r,c, cleared:false, url: '', quiz: ct});
      }
    }

    // Trace avec pile pour effacer en arri√®re
    const visited = new Set();
    const key = (r,c)=> `${r},${c}`;
    const trailStack = [];
    visited.add(key(...start));
    trailStack.push([...start]);

    state={ R,C, cell, padX, padY, walls, start, goal, pos:[...start], path,
            steps:0, paused:false, checkpoints, visited, key, trailStack };
    updateHUD();
    drawAll();
  }

  function updateHUD(){
    stepsTag.textContent = `Pas: ${state.steps}`;
    const cleared = state.checkpoints.filter(c=>c.cleared).length;
    checksTag.textContent = `Checkpoints: ${cleared}/${state.checkpoints.length}`;
  }

  function drawAll(){
    const {R,C,cell,padX,padY,walls,pos,goal,checkpoints,visited} = state;
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.save(); ctx.translate(padX+.5, padY+.5);

    // Cases visit√©es ‚Äì bleu un peu plus fonc√©
    if (trailInp.checked) {
      ctx.fillStyle = 'rgba(37,99,235,0.25)';
      for (const v of visited) {
        const [rr, cc] = v.split(',').map(Number);
        ctx.fillRect(cc*cell, rr*cell, cell, cell);
      }
    }

    // Grille ‚Äì bleu l√©g√®rement fonc√©
    ctx.strokeStyle = 'rgba(37,99,235,0.35)';
    ctx.lineWidth = 1;
    for(let r=0;r<=R;r++){ ctx.beginPath(); ctx.moveTo(0, r*cell); ctx.lineTo(C*cell, r*cell); ctx.stroke(); }
    for(let c=0;c<=C;c++){ ctx.beginPath(); ctx.moveTo(c*cell, 0); ctx.lineTo(c*cell, R*cell); ctx.stroke(); }

    // Murs
    ctx.strokeStyle = '#0b0b0b'; ctx.lineWidth = 3;
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        const x=c*cell, y=r*cell; const w=walls[r][c];
        if(w[0]){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+cell, y); ctx.stroke(); }
        if(w[1]){ ctx.beginPath(); ctx.moveTo(x+cell, y); ctx.lineTo(x+cell, y+cell); ctx.stroke(); }
        if(w[2]){ ctx.beginPath(); ctx.moveTo(x, y+cell); ctx.lineTo(x+cell, y+cell); ctx.stroke(); }
        if(w[3]){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+cell); ctx.stroke(); }
      }
    }

    // Checkpoints
    for(const cp of checkpoints){
      const x = cp.c*cell + cell/2, y = cp.r*cell + cell/2;
      ctx.beginPath(); ctx.arc(x, y, Math.max(4, cell*0.18), 0, Math.PI*2);
      ctx.fillStyle = cp.cleared ? '#10b981' : '#f59e0b';
      ctx.fill();
    }

    // Sortie
    ctx.beginPath();
    ctx.fillStyle = '#22c55e';
    ctx.arc(goal[1]*cell+cell/2, goal[0]*cell+cell/2, Math.max(5, cell*0.20), 0, Math.PI*2);
    ctx.fill();

    // Joueur
    ctx.beginPath();
    ctx.fillStyle = '#38bdf8';
    ctx.arc(pos[1]*cell+cell/2, pos[0]*cell+cell/2, Math.max(5, cell*0.20), 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function tryMove(dr,dc){
    if(state.paused) return;
    const [r,c]=state.pos;
    const nr=r+dr, nc=c+dc;
    if(nr<0||nc<0||nr>=state.R||nc>=state.C) return;

    const dirIndex = dr===-1?0: dc===1?1: dr===1?2: 3;
    if(state.walls[r][c][dirIndex]) return;

    // D√©placement accept√©
    state.pos=[nr,nc];
    state.steps++;

    // Gestion de la trace avec effacement si on revient en arri√®re
    if (trailInp.checked) {
      const kPrev = state.key(r,c);
      const kNew  = state.key(nr,nc);
      const stack = state.trailStack;
      // Backtrack si on retourne sur la case pr√©c√©dente de la pile
      if (stack.length >= 2) {
        const [pr, pc] = stack[stack.length-2];
        if (pr === nr && pc === nc) {
          // on retire l'ancienne t√™te (r,c) de la pile, et on l'efface du "visited"
          const removed = stack.pop(); // (r,c)
          state.visited.delete(state.key(removed[0], removed[1]));
          updateHUD(); drawAll(); checkCell();
          return;
        }
      }
      // sinon on progresse : on ajoute √† la pile et √† visited
      stack.push([nr,nc]);
      state.visited.add(kNew);
    }

    updateHUD(); drawAll();
    checkCell();
  }

  function checkCell(){
    const cp = state.checkpoints.find(x=>!x.cleared && x.r===state.pos[0] && x.c===state.pos[1]);
    if(cp){
      if(cp.url){ window.open(cp.url,'_blank'); cp.cleared=true; updateHUD(); drawAll(); return; }
      showQuiz(cp);
    }
    if(state.pos[0]===state.goal[0] && state.pos[1]===state.goal[1]){
      setTimeout(()=>{ alert('üéâ Bravo ! Tu as atteint la sortie.'); }, 50);
    }
  }

  function showQuiz(cp){
    state.paused=true; modal.style.display='grid'; qHint.style.display='none';
    qTitle.textContent = cp.quiz.title; qText.textContent = cp.quiz.text;
    qChoices.innerHTML='';
    cp.quiz.choices.forEach((ch)=>{
      const b=document.createElement('button'); b.textContent=ch.label;
      b.onclick=()=>{
        if(ch.correct){ b.classList.add('correct'); setTimeout(()=>{ modal.style.display='none'; state.paused=false; cp.cleared=true; updateHUD(); drawAll(); }, 280); }
        else { b.classList.add('wrong'); qHint.style.display='block'; }
      };
      qChoices.appendChild(b);
    });
  }

  // Sauvegarde simple des r√©glages locaux
  function saveSettings(){
    const data = {
      rows: rowsInp.value,
      cols: colsInp.value,
      seed: seedInp.value,
      numChecks: numChecksInp.value,
      startCorner: startCornerSel.value,
      trail: trailInp.checked
    };
    localStorage.setItem('mazeSettings_color_back', JSON.stringify(data));
  }
  function loadSettings(){
    const raw = localStorage.getItem('mazeSettings_color_back');
    if(!raw) return;
    try{
      const d = JSON.parse(raw);
      if(d.rows) rowsInp.value = d.rows;
      if(d.cols) colsInp.value = d.cols;
      if(d.seed !== undefined) seedInp.value = d.seed;
      if(d.numChecks) numChecksInp.value = d.numChecks;
      if(d.startCorner) startCornerSel.value = d.startCorner;
      if(d.trail !== undefined) trailInp.checked = d.trail;
    }catch(e){}
  }

  [rowsInp, colsInp, seedInp, numChecksInp, startCornerSel, trailInp].forEach(el => el.addEventListener('change', saveSettings));

  window.addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(k==='arrowup'||k==='w'||k==='z'){ e.preventDefault(); tryMove(-1,0); }
    if(k==='arrowright'||k==='d'){ e.preventDefault(); tryMove(0,1); }
    if(k==='arrowdown'||k==='s'){ e.preventDefault(); tryMove(1,0); }
    if(k==='arrowleft'||k==='a'||k==='q'){ e.preventDefault(); tryMove(0,-1); }
    if(k===' '){ state.paused=!state.paused; }
  });

  let touchStart=null;
  canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; touchStart=[t.clientX,t.clientY]; });
  canvas.addEventListener('touchend', e=>{
    if(!touchStart) return; const t=e.changedTouches[0]; const dx=t.clientX-touchStart[0], dy=t.clientY-touchStart[1];
    if(Math.abs(dx)>Math.abs(dy)) { if(dx>10) tryMove(0,1); else if(dx<-10) tryMove(0,-1); }
    else { if(dy>10) tryMove(1,0); else if(dy<-10) tryMove(-1,0); }
    touchStart=null;
  });

  loadSettings();
  document.getElementById('regen').onclick = ()=> { saveSettings(); newGame(); };
  document.getElementById('reset').onclick = ()=> {
    state.pos=[...state.start]; state.steps=0; state.checkpoints.forEach(c=>c.cleared=false);
    state.visited = new Set([`${state.start[0]},${state.start[1]}`]);
    state.trailStack = [[...state.start]];
    updateHUD(); drawAll();
  };
  document.getElementById('closeModal').onclick = ()=>{ modal.style.display='none'; state.paused=false; };

  newGame();
  </script>
</body>
</html>
